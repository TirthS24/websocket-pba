# CDK Infrastructure Configuration
# Copy this file to .env and fill in your values

# Environment name (stage, live, etc.)
ENVIRONMENT=stage

# AWS Configuration
AWS_ACCOUNT_ID=123456789012
AWS_REGION=us-east-1

# VPC Configuration (existing VPC)
VPC_ID=vpc-xxxxxxxxxxxxxxxxx
PUBLIC_SUBNET_IDS=subnet-xxxxxxxxxxxxxxxxx,subnet-yyyyyyyyyyyyyyyyy
PRIVATE_SUBNET_IDS=subnet-aaaaaaaaaaaaaaaaa,subnet-bbbbbbbbbbbbbbbbb
PUBLIC_ROUTE_TABLE_IDS=rtb-xxxxxxxxxxxxxxxxx,rtb-yyyyyyyyyyyyyyyyy
PRIVATE_ROUTE_TABLE_IDS=rtb-aaaaaaaaaaaaaaaaa,rtb-bbbbbbbbbbbbbbbbb

# ECR Repositories (existing repository names)
# ws_server image is pushed to ECR_REPOSITORY_NAME; LLM image to ECR_LLM_REPOSITORY_NAME.
# For one repo with two tags, set both to the same value (deploy.sh will use distinct tags).
ECR_REPOSITORY_NAME=your-ecr-repo-name
ECR_LLM_REPOSITORY_NAME=your-ecr-repo-name

# Container Configuration
CONTAINER_PORT=8000
# Two ECS services (same cluster): ws_server and LLM. Scale independently.
DESIRED_TASK_COUNT=2
MIN_TASK_COUNT=2
MAX_TASK_COUNT=4
# Optional: LLM service scale (defaults to same as above if unset)
# DESIRED_LLM_TASK_COUNT=2
# MIN_LLM_TASK_COUNT=2
# MAX_LLM_TASK_COUNT=4

# Django Application Environment Variables
# These will be passed to ECS tasks
DJANGO_SECRET_KEY=your-secret-key-here
DJANGO_DEBUG=0
DJANGO_ALLOWED_HOSTS=your-alb-dns-name.elb.amazonaws.com

# Instance identity
INSTANCE_ID=ecs-fargate

# Optional Database
# DATABASE_URL=postgres://user:pass@host:5432/dbname

# LangGraph / Chatbot Configuration
PSQL_BOT_USERNAME=your_username
PSQL_BOT_PASSWORD=your_password
PSQL_FE_USERNAME=your_username
PSQL_FE_PASSWORD=your_password
PSQL_HOST=your-postgres-host
PSQL_PORT=5432
PSQL_STATE_DATABASE=langgraph_state
PSQL_DATA_DATABASE=langgraph_data
PSQL_SSLMODE=require

# AWS Bedrock Configuration
AWS_BEDROCK_REGION=us-east-1
BEDROCK_MODEL_ID_BILLING_AGENT=your_model_id
BEDROCK_MODEL_ID_CLAIM_AGENT=your_model_id
BEDROCK_MODEL_ID_ESCALATION_DETECTION=your_model_id
BEDROCK_MODEL_ID_INTENT_DETECTION=your_model_id
BEDROCK_MODEL_ID_SMS_ROUTER=your_model_id
BEDROCK_MODEL_ID_THREAD_SUMMARIZE=your_model_id
BEDROCK_MODEL_ID_SMS_RESPOND=your_model_id
BEDROCK_MODEL_ID_WEB_RESPOND=your_model_id

# Guardrails
MAXIMUM_GUARDRAIL_REWRITES=3

# API Authentication
AUTH_API_KEY=your-api-key-here

# Redis (Channels layer, presence, etc.)
# Local/docker-compose: redis://127.0.0.1:6379/0 or redis://redis:6379/0
# ECS: Set automatically from ElastiCache by the stack; deploy.sh exports REDIS_URL from stack output.
# REDIS_URL=redis://127.0.0.1:6379/0
# Optional: ElastiCache node type (default: cache.t3.micro)
# REDIS_CACHE_NODE_TYPE=cache.t3.micro

# LLM service (used by ws_server POST /api/thread/connect)
# Local/docker-compose: use http://llm:7980 or http://localhost:7980
LLM_SERVICE_URL=http://localhost:7980
# ECS: The stack injects LLM_SERVICE_URL from the LLM ALB DNS. deploy.sh exports it from stack output.
LLM_SERVICE_AUTH=

# WebSocket server URL (used by LLM to connect to ws_server)
# Local/docker-compose: ws://web:8000 or http://localhost:8000
# ECS: The stack injects WS_SERVER_URL and WS_SERVER_ORIGIN from the ws_server ALB DNS.
# WS_SERVER_URL=ws://localhost:8000
# WS_SERVER_ORIGIN=http://localhost:8000

# CSRF Protection
CSRF_SECRET_KEY=your-csrf-secret-key-here

# ECR Image Tag: leave unset or set to "latest" to use timestamp (recommended).
# Set to a specific tag (e.g. v1.2.3) to push that tag to ECR for both ws_server and LLM.
# ECR_IMAGE_TAG=
