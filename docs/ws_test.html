<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebSocket Chat Test - websocket-pba</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }
      
      .container {
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        width: 100%;
        max-width: 1200px;
        height: 90vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      
      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 24px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .header-actions {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      
      .header-button {
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
      }
      
      .header-button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-1px);
      }
      
      .header-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      .header h1 {
        font-size: 24px;
        font-weight: 600;
      }
      
      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }
      
      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #ff4444;
        animation: pulse 2s infinite;
      }
      
      .status-dot.connected {
        background: #44ff44;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
      
      .main-content {
        display: flex;
        flex: 1;
        overflow: hidden;
      }
      
      .chat-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        border-right: 1px solid #e5e7eb;
      }
      
      .settings-panel {
        width: 350px;
        background: #f9fafb;
        padding: 20px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      
      .settings-section {
        background: white;
        padding: 16px;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      
      .settings-section h3 {
        font-size: 14px;
        font-weight: 600;
        color: #374151;
        margin-bottom: 12px;
      }
      
      .settings-section label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        color: #6b7280;
        margin-bottom: 6px;
      }
      
      .settings-section input,
      .settings-section select,
      .settings-section textarea {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 14px;
        transition: border-color 0.2s;
      }
      
      .settings-section input:focus,
      .settings-section select:focus,
      .settings-section textarea:focus {
        outline: none;
        border-color: #667eea;
      }
      
      .settings-section textarea {
        min-height: 100px;
        font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
        font-size: 12px;
        resize: vertical;
      }
      
      .messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: #f9fafb;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      
      .message {
        max-width: 70%;
        padding: 12px 16px;
        border-radius: 12px;
        word-wrap: break-word;
        animation: slideIn 0.3s ease-out;
      }
      
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      .message.user {
        align-self: flex-end;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-bottom-right-radius: 4px;
      }
      
      .message.assistant {
        align-self: flex-start;
        background: white;
        color: #374151;
        border: 1px solid #e5e7eb;
        border-bottom-left-radius: 4px;
      }
      
      .message.static {
        align-self: flex-start;
        background: #fef3c7;
        color: #92400e;
        border: 1px solid #fde68a;
        border-bottom-left-radius: 4px;
      }
      
      .message.system {
        align-self: center;
        background: #e0e7ff;
        color: #3730a3;
        font-size: 12px;
        padding: 8px 12px;
        max-width: 90%;
        text-align: center;
      }
      
      .message.summary,
      .message.history {
        align-self: flex-start;
        background: #f0f9ff;
        color: #0c4a6e;
        border: 1px solid #bae6fd;
        border-bottom-left-radius: 4px;
        max-width: 85%;
      }
      
      .message.summary .message-header,
      .message.history .message-header {
        font-weight: 600;
        opacity: 1;
      }
      
      .message-content {
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      
      .message-header {
        font-size: 11px;
        opacity: 0.7;
        margin-bottom: 4px;
        font-weight: 500;
      }
      
      .input-area {
        padding: 20px;
        background: white;
        border-top: 1px solid #e5e7eb;
        display: flex;
        gap: 12px;
        align-items: flex-end;
      }
      
      .input-wrapper {
        flex: 1;
        position: relative;
      }
      
      .input-wrapper textarea {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid #e5e7eb;
        border-radius: 12px;
        font-size: 14px;
        font-family: inherit;
        resize: none;
        min-height: 50px;
        max-height: 150px;
        transition: border-color 0.2s;
      }
      
      .input-wrapper textarea:focus {
        outline: none;
        border-color: #667eea;
      }
      
      .send-button {
        padding: 12px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        min-width: 100px;
      }
      
      .send-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }
      
      .send-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      .thread-id-display {
        font-size: 11px;
        color: #6b7280;
        margin-top: 8px;
        word-break: break-all;
      }
      
      .button-secondary {
        padding: 8px 16px;
        background: #f3f4f6;
        color: #374151;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      
      .button-secondary:hover {
        background: #e5e7eb;
      }
      
      .collapsible {
        cursor: pointer;
        user-select: none;
      }
      
      .collapsible::after {
        content: ' ▼';
        font-size: 10px;
        opacity: 0.6;
      }
      
      .collapsible.collapsed::after {
        content: ' ▶';
      }
      
      .collapsible-content {
        max-height: 500px;
        overflow: hidden;
        transition: max-height 0.3s ease-out;
      }
      
      .collapsible-content.collapsed {
        max-height: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>WebSocket Chat Test</h1>
        <div class="header-actions">
          <button class="header-button" id="getSummaryButton" disabled>Get Summary</button>
          <button class="header-button" id="getHistoryButton" disabled>Get History</button>
          <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Disconnected</span>
          </div>
        </div>
      </div>
      
      <div class="main-content">
        <div class="chat-area">
          <div class="messages" id="messages"></div>
          <div class="input-area">
            <div class="input-wrapper">
              <textarea 
                id="messageInput" 
                placeholder="Type your message here..."
                rows="1"
              ></textarea>
              <div class="thread-id-display" id="threadIdDisplay"></div>
            </div>
            <button class="send-button" id="sendButton" disabled>Send</button>
          </div>
        </div>
        
        <div class="settings-panel">
          <div class="settings-section">
            <h3>Connection Settings</h3>
            <label for="httpBase">HTTP Base URL</label>
            <input id="httpBase" value="http://localhost:8000" placeholder="http://localhost:8000" />
            
            <label for="wsBaseUrl" style="margin-top: 12px;">WebSocket Base URL</label>
            <input id="wsBaseUrl" value="ws://localhost:8000" placeholder="ws://localhost:8000" />
          </div>
          
          <div class="settings-section">
            <h3>Chat Settings</h3>
            <label for="channel">Channel</label>
            <select id="channel">
              <option value="web" selected>web</option>
              <option value="sms">sms</option>
            </select>
            
            <label for="threadId" style="margin-top: 12px;">Thread ID</label>
            <div style="display: flex; gap: 8px;">
              <input id="threadId" placeholder="Auto-generated on first message" readonly style="flex: 1;" />
              <button class="button-secondary" id="clearThread">Clear</button>
            </div>
          </div>
          
          <div class="settings-section">
            <h3 class="collapsible" id="dataCollapsible">Data JSON (required for channel=web)</h3>
            <div class="collapsible-content" id="dataContent">
              <textarea id="dataJson">[
  {
    "external_id": "practice-001",
    "name": "Demo Medical Practice",
    "platform": "PatriotPay",
    "email_address": "contact@demopractice.com",
    "phone_number": "555-0100",
    "patients": [
      {
        "external_id": "patient-001",
        "first_name": "John",
        "last_name": "Doe",
        "gender": "M",
        "phone_number": "555-0101",
        "email_address": "john.doe@email.com",
        "dob": "1985-03-15",
        "claims": [],
        "patient_payments": []
      }
    ]
  }
]</textarea>
            </div>
          </div>
          
          <div class="settings-section">
            <h3 class="collapsible collapsed" id="logCollapsible">Debug Log</h3>
            <div class="collapsible-content collapsed" id="logContent">
              <div id="log" style="background: #1f2937; color: #d1d5db; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 11px; max-height: 300px; overflow-y: auto; white-space: pre-wrap;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);
      const API_KEY = "abcdefg123456uadslvaosdiufdspofu9sp";  // Hardcoded API key
      const messagesEl = $("messages");
      const logEl = $("log");
      const statusDot = $("statusDot");
      const statusText = $("statusText");
      let ws = null;
      let threadId = null;
      let currentMessage = "";
      let csrfToken = null;  // Cache CSRF token to reuse across requests

      function log(line) {
        logEl.textContent += line + "\n";
        logEl.scrollTop = logEl.scrollHeight;
      }

      function updateStatus(connected) {
        if (connected) {
          statusDot.classList.add("connected");
          statusText.textContent = "Connected";
        } else {
          statusDot.classList.remove("connected");
          statusText.textContent = "Disconnected";
        }
      }

      function addMessage(text, type = "assistant") {
        const messageEl = document.createElement("div");
        messageEl.className = `message ${type}`;
        
        if (type === "assistant" || type === "static" || type === "summary" || type === "history") {
          const header = document.createElement("div");
          header.className = "message-header";
          if (type === "static") {
            header.textContent = "Static Message";
          } else if (type === "summary") {
            header.textContent = "Thread Summary";
          } else if (type === "history") {
            header.textContent = "Thread History";
          } else {
            header.textContent = "Assistant";
          }
          messageEl.appendChild(header);
        }
        
        const content = document.createElement("div");
        content.className = "message-content";
        content.textContent = text;
        messageEl.appendChild(content);
        
        messagesEl.appendChild(messageEl);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function buildWsUrl(endpoint, apiKey) {
        const baseUrl = $("wsBaseUrl").value.trim().replace(/\/$/, "");
        let url = `${baseUrl}${endpoint}`;
        if (apiKey) {
          const separator = url.includes("?") ? "&" : "?";
          url = `${url}${separator}authorization=${encodeURIComponent(apiKey)}`;
        }
        return url;
      }

      async function getCsrfToken(forceRefresh = false) {
        // Return cached token if available and not forcing refresh
        if (csrfToken && !forceRefresh) {
          log(`Using cached CSRF token: ${csrfToken.substring(0, 10)}...`);
          // Verify cookie is still available
          const cookieValue = getCookie("csrftoken");
          if (cookieValue) {
            log(`CSRF cookie verified: ${cookieValue.substring(0, 10)}...`);
          } else {
            log("Warning: CSRF cookie not found, refreshing token...");
            csrfToken = null;
            return await getCsrfToken(true);
          }
          return { token: csrfToken, cookie: cookieValue };
        }
        
        const httpBase = $("httpBase").value.trim();
        if (!httpBase) {
          log("HTTP Base URL is required for CSRF token");
          return null;
        }
        try {
          const url = `${httpBase.replace(/\/$/, "")}/api/csrf-token/`;
          const headers = {
            "Authorization": API_KEY
          };
          const response = await fetch(url, {
            method: "GET",
            headers: headers,
            credentials: "include",  // Required for cookies to be set/sent
            mode: "cors"  // Explicitly request CORS
          });
          if (!response.ok) {
            const errorText = await response.text().catch(() => response.statusText);
            log(`Failed to get CSRF token: ${response.status} ${response.statusText}`);
            log(`Response: ${errorText}`);
            // Check if it's a CORS error
            if (response.status === 0 || response.type === "opaque") {
              log("CORS error detected. Make sure:");
              log("1. The server has CORS enabled");
              log("2. Your origin is in CORS_ALLOWED_ORIGINS");
              log("3. You're accessing via http:// not file://");
            }
            return null;
          }
          
          // Check for Set-Cookie header
          const setCookieHeader = response.headers.get("set-cookie");
          if (setCookieHeader) {
            log(`Set-Cookie header received: ${setCookieHeader.substring(0, 50)}...`);
          } else {
            log("Warning: No Set-Cookie header in response");
          }
          
          const data = await response.json();
          const token = data.csrf_token;
          if (!token) {
            log("CSRF token not found in response");
            return null;
          }
          
          // Cache the token for reuse
          csrfToken = token;
          log(`CSRF token obtained and cached: ${token.substring(0, 10)}...`);
          
          // Verify cookie was set by browser
          // Wait a brief moment for cookie to be processed
          await new Promise(resolve => setTimeout(resolve, 100));
          const cookieValue = getCookie("csrftoken");
          if (cookieValue) {
            log(`CSRF cookie verified: ${cookieValue.substring(0, 10)}...`);
            log("✓ CSRF protection is properly configured");
          } else {
            log("⚠ Warning: CSRF cookie not found after fetch. This may cause CSRF errors.");
            log("Possible causes:");
            log("1. Browser blocking SameSite=None cookies without Secure flag");
            log("   - Safari is strict: requires Secure=True with SameSite=None");
            log("   - Chrome/Firefox on localhost: usually allow Secure=False");
            log("2. Browser blocking third-party cookies");
            log("3. CORS not configured to allow credentials");
            log("");
            log("Solutions:");
            log("- Try Chrome or Firefox (more lenient with localhost)");
            log("- Use HTTPS in production (allows Secure=True)");
            log("- Serve HTML from same origin as API (avoids cross-origin)");
            log("");
            log("Note: Requests may still work if browser sends cookie automatically");
          }
          
          return { token, cookie: cookieValue };
        } catch (e) {
          log(`Error fetching CSRF token: ${e.message}`);
          if (e.message.includes("CORS") || e.message.includes("Failed to fetch")) {
            log("CORS error detected. Make sure:");
            log("1. The server has CORS enabled (CORS_ALLOW_ALL_ORIGINS=True in DEBUG mode)");
            log("2. You're accessing the HTML file via http:// not file://");
            log("3. The server is running and accessible");
            log("4. CORS is configured to allow credentials (Access-Control-Allow-Credentials: true)");
          }
          return null;
        }
      }
      
      function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) {
          return parts.pop().split(';').shift();
        }
        return null;
      }
      
      async function postJson(path, payload) {
        const httpBase = $("httpBase").value.trim();
        if (!httpBase) {
          log("HTTP Base URL is required");
          return null;
        }
        
        // Get CSRF token (will use cached token if available)
        const csrf = await getCsrfToken();
        if (!csrf) {
          log("Failed to get CSRF token");
          return null;
        }
        
        const url = `${httpBase.replace(/\/$/, "")}${path}`;
        const headers = {
          "Content-Type": "application/json",
          "X-CSRFToken": csrf.token,
        };
        if (API_KEY) {
          headers["Authorization"] = API_KEY;
        }
        
        // Verify cookie is available before sending request
        const cookieValue = getCookie("csrftoken");
        if (!cookieValue && csrf.cookie) {
          log("Warning: CSRF cookie not found in document.cookie, but token available");
        }
        
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: headers,
            body: JSON.stringify(payload),
            credentials: "include",  // Required: Include cookies (CSRF cookie will be sent automatically)
            mode: "cors"
          });
          
          // If we get a 403 CSRF error, try refreshing the token once
          if (response.status === 403) {
            const errorText = await response.text().catch(() => response.statusText);
            if (errorText.includes("CSRF") || errorText.includes("csrf")) {
              log("CSRF validation failed, refreshing token and retrying...");
              csrfToken = null;  // Clear cache
              const refreshedCsrf = await getCsrfToken(true);
              if (refreshedCsrf) {
                headers["X-CSRFToken"] = refreshedCsrf.token;
                // Retry the request once
                const retryResponse = await fetch(url, {
                  method: "POST",
                  headers: headers,
                  body: JSON.stringify(payload),
                  credentials: "include",
                  mode: "cors"
                });
                if (!retryResponse.ok) {
                  const retryErrorText = await retryResponse.text().catch(() => retryResponse.statusText);
                  log(`HTTP ${retryResponse.status} after retry: ${retryErrorText}`);
                  return null;
                }
                const retryText = await retryResponse.text();
                return retryText ? JSON.parse(retryText) : {};
              }
            }
            log(`HTTP ${response.status}: ${errorText}`);
            return null;
          }
          
          if (!response.ok) {
            const errorText = await response.text().catch(() => response.statusText);
            log(`HTTP ${response.status}: ${errorText}`);
            return null;
          }
          
          const text = await response.text();
          const data = text ? JSON.parse(text) : {};
          return data;
        } catch (e) {
          log(`Error in POST request: ${e.message}`);
          return null;
        }
      }
      
      async function getSummary() {
        if (!threadId) {
          addMessage("Error: No thread ID available. Send a message first.", "system");
          return;
        }
        
        $("getSummaryButton").disabled = true;
        addMessage("Fetching thread summary...", "system");
        log(`[client] Fetching summary for thread_id=${threadId}`);
        
        const data = await postJson("/api/thread/summarize", { thread_id: threadId });
        
        $("getSummaryButton").disabled = false;
        
        if (data && data.summary) {
          addMessage(data.summary, "summary");
          log(`[summary] ${data.summary.substring(0, 100)}...`);
        } else {
          addMessage("Error: Failed to get summary", "system");
          log(`[error] Failed to get summary`);
        }
      }
      
      async function getHistory() {
        if (!threadId) {
          addMessage("Error: No thread ID available. Send a message first.", "system");
          return;
        }
        
        $("getHistoryButton").disabled = true;
        addMessage("Fetching thread history...", "system");
        log(`[client] Fetching history for thread_id=${threadId}`);
        
        const data = await postJson("/api/thread/history", { thread_id: threadId });
        
        $("getHistoryButton").disabled = false;
        
        if (data && data.messages) {
          const historyText = data.messages.map((msg, idx) => {
            const role = msg.type === "ai" ? "Assistant" : msg.type === "human" ? "User" : msg.type;
            const content = typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content);
            return `${idx + 1}. [${role}]: ${content}`;
          }).join("\n\n");
          
          addMessage(historyText || "No messages in history", "history");
          log(`[history] Retrieved ${data.messages.length} messages`);
        } else {
          addMessage("Error: Failed to get history", "system");
          log(`[error] Failed to get history`);
        }
      }

      async function connectToChat() {
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
          log("Already connected/connecting.");
          return;
        }
        
        // Get CSRF token first
        const csrf = await getCsrfToken();
        if (!csrf) {
          log("Warning: Could not get CSRF token, proceeding anyway...");
        }
        
        // Build WebSocket URL with authorization
        const url = buildWsUrl("/ws/chat/", API_KEY);
        
        log(`Connecting to chat: ${url}`);
        updateStatus(false);
        ws = new WebSocket(url);
        
        ws.onopen = () => {
          log("Chat WS open");
          updateStatus(true);
          $("sendButton").disabled = false;
          // Enable summary/history buttons if we have a thread_id
          if (threadId) {
            $("getSummaryButton").disabled = false;
            $("getHistoryButton").disabled = false;
          }
        };
        
        ws.onclose = (e) => {
          log(`Chat WS close code=${e.code} reason=${e.reason || ""}`.trim());
          updateStatus(false);
          $("sendButton").disabled = true;
        };
        
        ws.onerror = (e) => {
          log("Chat WS error (see console)");
          updateStatus(false);
        };
        
        ws.onmessage = (e) => {
          try {
            const msg = JSON.parse(e.data);
            const msgType = msg.type || msg.event;
            
            if (msgType === "connected") {
              log(`[connected] connection_id=${msg.connection_id}`);
            } else if (msgType === "thread_initialized") {
              threadId = msg.thread_id;
              $("threadId").value = threadId;
              $("threadIdDisplay").textContent = `Thread ID: ${threadId}`;
              log(`[thread_initialized] Thread ID: ${threadId}`);
              addMessage(`Session initialized with thread ID: ${threadId}`, "system");
              // Enable summary/history buttons now that we have a thread_id
              $("getSummaryButton").disabled = false;
              $("getHistoryButton").disabled = false;
            } else if (msgType === "token") {
              currentMessage += msg.content || "";
              // Update the last assistant message or create a new one
              const lastMsg = messagesEl.lastElementChild;
              if (lastMsg && lastMsg.classList.contains("assistant")) {
                lastMsg.lastElementChild.textContent = currentMessage;
              } else {
                addMessage(msg.content || "", "assistant");
                currentMessage = msg.content || "";
              }
              messagesEl.scrollTop = messagesEl.scrollHeight;
            } else if (msgType === "static") {
              addMessage(msg.content || "", "static");
              log(`[static] ${msg.content}`);
            } else if (msgType === "escalation") {
              addMessage(`Escalation detected: ${msg.should_escalate}`, "system");
              log(`[escalation] should_escalate=${msg.should_escalate}`);
            } else if (msgType === "end") {
              currentMessage = "";
              log(`[end]`);
            } else if (msgType === "error") {
              addMessage(`Error: ${msg.message}`, "system");
              log(`[error] ${msg.message}`);
            } else {
              log(`[${msgType}] ${e.data}`);
            }
          } catch {
            log(String(e.data));
          }
        };
      }

      // Initialize CSRF token on page load (fetch once, reuse for all requests)
      getCsrfToken().then(csrf => {
        if (csrf) {
          log("CSRF token initialized and ready for use");
        }
      });
      
      // Auto-connect when page loads
      connectToChat();

      $("sendButton").addEventListener("click", async () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          log("Error: Not connected to chat endpoint.");
          await connectToChat();
          // Wait a bit for connection
          await new Promise(resolve => setTimeout(resolve, 500));
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            addMessage("Error: Could not connect. Please check your settings.", "system");
            return;
          }
        }
        
        const channel = $("channel").value;
        const message = $("messageInput").value.trim();
        
        if (!message) {
          return;
        }
        
        // Add user message to chat
        addMessage(message, "user");
        $("messageInput").value = "";
        $("messageInput").style.height = "auto";
        
        // Build payload
        const payload = { 
          type: "chat", 
          channel, 
          message
        };
        
        // Add thread_id if we have one
        if (threadId) {
          payload.thread_id = threadId;
        }
        
        // Data is required when channel is web
        if (channel === "web") {
          const dataJson = $("dataJson").value.trim();
          if (!dataJson) {
            addMessage("Error: Data JSON is required when channel is web", "system");
            return;
          }
          try {
            payload.data = JSON.parse(dataJson);
          } catch (e) {
            addMessage(`Error: Invalid data JSON: ${e.message}`, "system");
            return;
          }
        }
        
        ws.send(JSON.stringify(payload));
        log(`[client] sent: ${JSON.stringify(payload)}`);
      });

      // Handle Enter key (Shift+Enter for new line)
      $("messageInput").addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          $("sendButton").click();
        }
      });

      // Auto-resize textarea
      $("messageInput").addEventListener("input", function() {
        this.style.height = "auto";
        this.style.height = Math.min(this.scrollHeight, 150) + "px";
      });

      // Clear thread ID
      $("clearThread").addEventListener("click", () => {
        threadId = null;
        $("threadId").value = "";
        $("threadIdDisplay").textContent = "";
        addMessage("Thread ID cleared. A new one will be created on next message.", "system");
        // Disable summary/history buttons when thread is cleared
        $("getSummaryButton").disabled = true;
        $("getHistoryButton").disabled = true;
      });
      
      // Summary and History button handlers
      $("getSummaryButton").addEventListener("click", getSummary);
      $("getHistoryButton").addEventListener("click", getHistory);

      // Collapsible sections
      $("dataCollapsible").addEventListener("click", function() {
        this.classList.toggle("collapsed");
        $("dataContent").classList.toggle("collapsed");
      });

      $("logCollapsible").addEventListener("click", function() {
        this.classList.toggle("collapsed");
        $("logContent").classList.toggle("collapsed");
      });
    </script>
  </body>
</html>
