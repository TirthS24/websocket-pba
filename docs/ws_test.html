<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebSocket Chat Test - websocket-pba</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }
      
      .container {
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        width: 100%;
        max-width: 1200px;
        height: 90vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      
      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 24px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .header-actions {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      
      .header-button {
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
      }
      
      .header-button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-1px);
      }
      
      .header-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      .header h1 {
        font-size: 24px;
        font-weight: 600;
      }
      
      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }
      
      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #ff4444;
        animation: pulse 2s infinite;
      }
      
      .status-dot.connected {
        background: #44ff44;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
      
      .main-content {
        display: flex;
        flex: 1;
        overflow: hidden;
      }
      
      .chat-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        border-right: 1px solid #e5e7eb;
      }
      
      .settings-panel {
        width: 350px;
        background: #f9fafb;
        padding: 20px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      
      .settings-section {
        background: white;
        padding: 16px;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      
      .settings-section h3 {
        font-size: 14px;
        font-weight: 600;
        color: #374151;
        margin-bottom: 12px;
      }
      
      .settings-section label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        color: #6b7280;
        margin-bottom: 6px;
      }
      
      .settings-section input,
      .settings-section select,
      .settings-section textarea {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 14px;
        transition: border-color 0.2s;
      }
      
      .settings-section input:focus,
      .settings-section select:focus,
      .settings-section textarea:focus {
        outline: none;
        border-color: #667eea;
      }
      
      .settings-section textarea {
        min-height: 100px;
        font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
        font-size: 12px;
        resize: vertical;
      }
      
      .messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: #f9fafb;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      
      .message {
        max-width: 70%;
        padding: 12px 16px;
        border-radius: 12px;
        word-wrap: break-word;
        animation: slideIn 0.3s ease-out;
      }
      
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      .message.user {
        align-self: flex-end;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-bottom-right-radius: 4px;
      }
      
      .message.assistant {
        align-self: flex-start;
        background: white;
        color: #374151;
        border: 1px solid #e5e7eb;
        border-bottom-left-radius: 4px;
      }
      
      .message.static {
        align-self: flex-start;
        background: #fef3c7;
        color: #92400e;
        border: 1px solid #fde68a;
        border-bottom-left-radius: 4px;
      }
      
      .message.system {
        align-self: center;
        background: #e0e7ff;
        color: #3730a3;
        font-size: 12px;
        padding: 8px 12px;
        max-width: 90%;
        text-align: center;
      }
      
      .message.summary,
      .message.history {
        align-self: flex-start;
        background: #f0f9ff;
        color: #0c4a6e;
        border: 1px solid #bae6fd;
        border-bottom-left-radius: 4px;
        max-width: 85%;
      }
      
      .message.summary .message-header,
      .message.history .message-header {
        font-weight: 600;
        opacity: 1;
      }
      
      .message-content {
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      
      .message-header {
        font-size: 11px;
        opacity: 0.7;
        margin-bottom: 4px;
        font-weight: 500;
      }
      
      .input-area {
        padding: 20px;
        background: white;
        border-top: 1px solid #e5e7eb;
        display: flex;
        gap: 12px;
        align-items: flex-end;
      }
      
      .input-wrapper {
        flex: 1;
        position: relative;
      }
      
      .input-wrapper textarea {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid #e5e7eb;
        border-radius: 12px;
        font-size: 14px;
        font-family: inherit;
        resize: none;
        min-height: 50px;
        max-height: 150px;
        transition: border-color 0.2s;
      }
      
      .input-wrapper textarea:focus {
        outline: none;
        border-color: #667eea;
      }
      
      .send-button {
        padding: 12px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        min-width: 100px;
      }
      
      .send-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }
      
      .send-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      .thread-id-display {
        font-size: 11px;
        color: #6b7280;
        margin-top: 8px;
        word-break: break-all;
      }
      
      .button-secondary {
        padding: 8px 16px;
        background: #f3f4f6;
        color: #374151;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      
      .button-secondary:hover {
        background: #e5e7eb;
      }
      
      .collapsible {
        cursor: pointer;
        user-select: none;
      }
      
      .collapsible::after {
        content: ' ▼';
        font-size: 10px;
        opacity: 0.6;
      }
      
      .collapsible.collapsed::after {
        content: ' ▶';
      }
      
      .collapsible-content {
        max-height: 500px;
        overflow: hidden;
        transition: max-height 0.3s ease-out;
      }
      
      .collapsible-content.collapsed {
        max-height: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>WebSocket Chat Test</h1>
        <div class="header-actions">
          <button class="header-button" id="getSummaryButton" disabled>Get Summary</button>
          <button class="header-button" id="getHistoryButton" disabled>Get History</button>
          <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Disconnected</span>
          </div>
        </div>
      </div>
      
      <div class="main-content">
        <div class="chat-area">
          <div class="messages" id="messages"></div>
          <div class="input-area">
            <div class="input-wrapper">
              <textarea 
                id="messageInput" 
                placeholder="Type your message here..."
                rows="1"
              ></textarea>
              <div class="thread-id-display" id="threadIdDisplay"></div>
            </div>
            <button class="send-button" id="sendButton" disabled>Send</button>
          </div>
        </div>
        
        <div class="settings-panel">
          <div class="settings-section">
            <h3>Connection Settings</h3>
            <label for="httpBase">HTTP Base URL</label>
            <!-- <input id="httpBase" value="http://WebSoc-ALBAE-XmkemFU9P4kp-321802927.us-east-2.elb.amazonaws.com" placeholder="http://WebSoc-ALBAE-XmkemFU9P4kp-321802927.us-east-2.elb.amazonaws.com" /> -->
            <input id="httpBase" value="http://localhost:8000" />
            
            <label for="wsBaseUrl" style="margin-top: 12px;">WebSocket Base URL</label>
            <!-- <input id="wsBaseUrl" value="ws://WebSoc-ALBAE-XmkemFU9P4kp-321802927.us-east-2.elb.amazonaws.com" placeholder="ws://WebSoc-ALBAE-XmkemFU9P4kp-321802927.us-east-2.elb.amazonaws.com" /> -->
            <input id="wsBaseUrl" value="ws://localhost:8000" />
            <label for="apiKey" style="margin-top: 12px;">API Key</label>
            <input id="apiKey" type="password" value="{API_KEY}" placeholder="Must match server AUTH_API_KEY" autocomplete="off" />
            <p style="font-size: 11px; color: #6b7280; margin-top: 4px;">Required. Auth is API key only (no CSRF or cookies). Must match server AUTH_API_KEY.</p>
          </div>
          
          <div class="settings-section">
            <h3>Chat Settings</h3>
            <label for="channel">Channel</label>
            <select id="channel">
              <option value="web" selected>web (WebSocket)</option>
              <option value="sms">sms (REST)</option>
            </select>
            <p id="channelHint" style="font-size: 11px; color: #6b7280; margin-top: 6px;">WebSocket streaming. Data JSON and optional invoice are sent.</p>
            
            <label for="threadId" style="margin-top: 12px;">Thread ID</label>
            <div style="display: flex; gap: 8px;">
              <input id="threadId" placeholder="Generated when connecting" readonly style="flex: 1;" />
              <button class="button-secondary" id="clearThread">New thread</button>
            </div>
          </div>
          
          <div class="settings-section">
            <h3 class="collapsible" id="dataCollapsible">Data JSON (required for channel=web)</h3>
            <div class="collapsible-content" id="dataContent">
              <textarea id="dataJson">[
  {
    "external_id": "practice-001",
    "name": "Demo Medical Practice",
    "platform": "PatriotPay",
    "email_address": "contact@demopractice.com",
    "phone_number": "555-0100",
    "patients": [
      {
        "external_id": "patient-001",
        "first_name": "John",
        "last_name": "Doe",
        "gender": "M",
        "phone_number": "555-0101",
        "email_address": "john.doe@email.com",
        "dob": "1985-03-15",
        "claims": [],
        "patient_payments": []
      }
    ]
  }
]</textarea>
            </div>
          </div>
          
          <div class="settings-section">
            <h3 class="collapsible collapsed" id="logCollapsible">Debug Log</h3>
            <div class="collapsible-content collapsed" id="logContent">
              <div id="log" style="background: #1f2937; color: #d1d5db; padding: 12px; border-radius: 6px; font-family: monospace; font-size: 11px; max-height: 300px; overflow-y: auto; white-space: pre-wrap;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);
      function getApiKey() {
        const el = $("apiKey");
        return (el && el.value != null) ? String(el.value).trim() : "";
      }
      const messagesEl = $("messages");
      const logEl = $("log");
      const statusDot = $("statusDot");
      const statusText = $("statusText");
      let ws = null;
      let threadId = null;
      let currentMessage = "";

      function log(line) {
        logEl.textContent += line + "\n";
        logEl.scrollTop = logEl.scrollHeight;
      }

      function updateStatus(connected) {
        if (connected) {
          statusDot.classList.add("connected");
          statusText.textContent = "Connected";
        } else {
          statusDot.classList.remove("connected");
          statusText.textContent = "Disconnected";
        }
      }

      function addMessage(text, type = "assistant") {
        const messageEl = document.createElement("div");
        messageEl.className = `message ${type}`;
        
        if (type === "assistant" || type === "static" || type === "summary" || type === "history") {
          const header = document.createElement("div");
          header.className = "message-header";
          if (type === "static") {
            header.textContent = "Static Message";
          } else if (type === "summary") {
            header.textContent = "Thread Summary";
          } else if (type === "history") {
            header.textContent = "Thread History";
          } else {
            header.textContent = "Assistant";
          }
          messageEl.appendChild(header);
        }
        
        const content = document.createElement("div");
        content.className = "message-content";
        content.textContent = text;
        messageEl.appendChild(content);
        
        messagesEl.appendChild(messageEl);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function generateThreadId() {
        if (typeof crypto !== "undefined" && crypto.randomUUID) {
          return crypto.randomUUID();
        }
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/x/g, () =>
          ((Math.random() * 16) | 0).toString(16)
        );
      }

      function ensureThreadId() {
        if (!threadId) {
          threadId = generateThreadId();
          $("threadId").value = threadId;
          $("threadIdDisplay").textContent = `Thread ID: ${threadId}`;
          log(`[client] Generated thread_id: ${threadId}`);
        }
        return threadId;
      }

      function buildWsUrl(endpoint, apiKey) {
        const baseUrl = $("wsBaseUrl").value.trim().replace(/\/$/, "");
        let url = `${baseUrl}${endpoint}`;
        if (apiKey) {
          const separator = url.includes("?") ? "&" : "?";
          url = `${url}${separator}authorization=${encodeURIComponent(apiKey)}`;
        }
        return url;
      }

      async function postJson(path, payload) {
        const httpBase = $("httpBase").value.trim();
        if (!httpBase) {
          log("HTTP Base URL is required");
          return null;
        }
        const url = `${httpBase.replace(/\/$/, "")}${path}`;
        const headers = { "Content-Type": "application/json" };
        if (getApiKey()) {
          headers["Authorization"] = getApiKey();
        }
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: headers,
            body: JSON.stringify(payload),
            credentials: "omit",
            mode: "cors"
          });
          if (!response.ok) {
            const errorText = await response.text().catch(() => response.statusText);
            log(`HTTP ${response.status}: ${errorText}`);
            return null;
          }
          const text = await response.text();
          return text ? JSON.parse(text) : {};
        } catch (e) {
          log(`Error in POST request: ${e.message}`);
          return null;
        }
      }
      
      async function getSummary() {
        if (!threadId) {
          addMessage("Error: No thread ID available. Send a message first.", "system");
          return;
        }
        
        $("getSummaryButton").disabled = true;
        addMessage("Fetching thread summary...", "system");
        log(`[client] Fetching summary for thread_id=${threadId}`);
        
        const data = await postJson("/api/thread/summarize", { thread_id: threadId });
        
        $("getSummaryButton").disabled = false;
        
        if (data && data.summary) {
          addMessage(data.summary, "summary");
          log(`[summary] ${data.summary.substring(0, 100)}...`);
        } else {
          addMessage("Error: Failed to get summary", "system");
          log(`[error] Failed to get summary`);
        }
      }
      
      async function getHistory() {
        if (!threadId) {
          addMessage("Error: No thread ID available. Send a message first.", "system");
          return;
        }
        
        $("getHistoryButton").disabled = true;
        addMessage("Fetching thread history...", "system");
        log(`[client] Fetching history for thread_id=${threadId}`);
        
        const data = await postJson("/api/thread/history", { thread_id: threadId });
        
        $("getHistoryButton").disabled = false;
        
        if (data && data.messages) {
          const historyText = data.messages.map((msg, idx) => {
            const role = msg.type === "ai" ? "Assistant" : msg.type === "human" ? "User" : msg.type;
            const content = typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content);
            return `${idx + 1}. [${role}]: ${content}`;
          }).join("\n\n");
          
          addMessage(historyText || "No messages in history", "history");
          log(`[history] Retrieved ${data.messages.length} messages`);
        } else {
          addMessage("Error: Failed to get history", "system");
          log(`[error] Failed to get history`);
        }
      }

      async function connectToChat() {
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
          log("Already connected/connecting.");
          return;
        }
        
        ensureThreadId();
        const url = buildWsUrl("/ws/chat/", getApiKey());
        log(`Connecting to chat: ${url.replace(/authorization=[^&]+/, "authorization=***")} (thread_id=${threadId})`);
        updateStatus(false);
        ws = new WebSocket(url);
        
        ws.onopen = () => {
          log("Chat WS open");
          updateStatus(true);
          $("sendButton").disabled = false;
          $("getSummaryButton").disabled = false;
          $("getHistoryButton").disabled = false;
        };
        
        ws.onclose = (e) => {
          log(`Chat WS close code=${e.code} reason=${e.reason || ""}`.trim());
          updateStatus(false);
          $("sendButton").disabled = $("channel").value === "web";
        };
        
        ws.onerror = (e) => {
          log("Chat WS error (see console)");
          updateStatus(false);
        };
        
        ws.onmessage = (e) => {
          try {
            const msg = JSON.parse(e.data);
            const msgType = msg.type || msg.event;
            
            if (msgType === "connected") {
              log(`[connected] connection_id=${msg.connection_id}`);
            } else if (msgType === "thread_initialized") {
              // Server may echo thread_id; keep our client-generated one unless server sends a different one
              if (msg.thread_id) {
                threadId = msg.thread_id;
                $("threadId").value = threadId;
                $("threadIdDisplay").textContent = `Thread ID: ${threadId}`;
                log(`[thread_initialized] Thread ID: ${threadId}`);
              }
            } else if (msgType === "token") {
              currentMessage += msg.content || "";
              // Update the last assistant message or create a new one
              const lastMsg = messagesEl.lastElementChild;
              if (lastMsg && lastMsg.classList.contains("assistant")) {
                lastMsg.lastElementChild.textContent = currentMessage;
              } else {
                addMessage(msg.content || "", "assistant");
                currentMessage = msg.content || "";
              }
              messagesEl.scrollTop = messagesEl.scrollHeight;
            } else if (msgType === "static") {
              addMessage(msg.content || "", "static");
              log(`[static] ${msg.content}`);
            } else if (msgType === "escalation") {
              addMessage(`Escalation: ${msg.content ?? msg.should_escalate ?? "—"}`, "system");
              log(`[escalation] content=${msg.content ?? msg.should_escalate}`);
            } else if (msgType === "end") {
              currentMessage = "";
              log(`[end]`);
            } else if (msgType === "error") {
              addMessage(`Error: ${msg.message}`, "system");
              log(`[error] ${msg.message}`);
            } else {
              log(`[${msgType}] ${e.data}`);
            }
          } catch {
            log(String(e.data));
          }
        };
      }

      connectToChat();
      // Ensure Send button state matches channel (SMS can send without connection)
      if ($("channel").value === "sms") {
        $("sendButton").disabled = false;
        $("channelHint").textContent = "REST API. No invoice or data sent; full response in one reply.";
      }

      $("sendButton").addEventListener("click", async () => {
        const channel = $("channel").value;
        const message = $("messageInput").value.trim();
        
        if (!message) {
          return;
        }
        
        // Ensure we have a thread_id (required by both endpoints)
        ensureThreadId();
        
        // Add user message to chat
        addMessage(message, "user");
        $("messageInput").value = "";
        $("messageInput").style.height = "auto";
        
        if (channel === "sms") {
          // SMS: call REST endpoint; no invoice, no data
          const payload = { message, thread_id: threadId };
          log(`[client] POST /api/chat/sms: ${JSON.stringify(payload)}`);
          $("sendButton").disabled = true;
          try {
            const data = await postJson("/api/chat/sms", payload);
            $("sendButton").disabled = false;
            if (data && (data.message !== undefined || data.detail)) {
              if (data.detail) {
                addMessage(`Error: ${typeof data.detail === "string" ? data.detail : JSON.stringify(data.detail)}`, "system");
                log(`[error] SMS API: ${data.detail}`);
              } else {
                addMessage(data.message || "", "assistant");
                log(`[sms] response message length=${(data.message || "").length}`);
              }
            } else {
              addMessage("Error: No response from SMS endpoint", "system");
              log("[error] SMS API: no message or detail in response");
            }
          } catch (e) {
            $("sendButton").disabled = false;
            addMessage(`Error: ${e.message}`, "system");
            log(`[error] SMS request failed: ${e.message}`);
          }
          return;
        }
        
        // Web: use WebSocket; require connection
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          log("Error: Not connected to chat endpoint.");
          await connectToChat();
          await new Promise(resolve => setTimeout(resolve, 500));
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            addMessage("Error: Could not connect. Please check your settings.", "system");
            return;
          }
        }
        
        const payload = { 
          type: "chat", 
          channel: "web", 
          message,
          thread_id: threadId,
          invoice: null
        };
        
        const dataJson = $("dataJson").value.trim();
        if (!dataJson) {
          addMessage("Error: Data JSON is required when channel is web", "system");
          return;
        }
        try {
          payload.data = JSON.parse(dataJson);
        } catch (e) {
          addMessage(`Error: Invalid data JSON: ${e.message}`, "system");
          return;
        }
        
        ws.send(JSON.stringify(payload));
        log(`[client] sent: ${JSON.stringify(payload)}`);
      });

      // Handle Enter key (Shift+Enter for new line)
      $("messageInput").addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          $("sendButton").click();
        }
      });

      // Auto-resize textarea
      $("messageInput").addEventListener("input", function() {
        this.style.height = "auto";
        this.style.height = Math.min(this.scrollHeight, 150) + "px";
      });

      // Channel change: update hint and Send button state (SMS does not require WS connection)
      $("channel").addEventListener("change", () => {
        const ch = $("channel").value;
        const hint = $("channelHint");
        if (ch === "sms") {
          hint.textContent = "REST API. No invoice or data sent; full response in one reply.";
          $("sendButton").disabled = false;
        } else {
          hint.textContent = "WebSocket streaming. Data JSON and optional invoice are sent.";
          $("sendButton").disabled = !ws || ws.readyState !== WebSocket.OPEN;
        }
      });

      // New thread: generate a new thread ID (required by chat endpoint)
      $("clearThread").addEventListener("click", () => {
        threadId = generateThreadId();
        $("threadId").value = threadId;
        $("threadIdDisplay").textContent = `Thread ID: ${threadId}`;
        addMessage("New thread ID generated. Send a message to start a new conversation.", "system");
        log(`[client] New thread_id: ${threadId}`);
        $("getSummaryButton").disabled = false;
        $("getHistoryButton").disabled = false;
      });
      
      // Summary and History button handlers
      $("getSummaryButton").addEventListener("click", getSummary);
      $("getHistoryButton").addEventListener("click", getHistory);

      // Collapsible sections
      $("dataCollapsible").addEventListener("click", function() {
        this.classList.toggle("collapsed");
        $("dataContent").classList.toggle("collapsed");
      });

      $("logCollapsible").addEventListener("click", function() {
        this.classList.toggle("collapsed");
        $("logContent").classList.toggle("collapsed");
      });
    </script>
  </body>
</html>
